
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let rt  = tokio::runtime::Builder::new_multi_thread()
    .worker_threads(std::cmp::max(2, num_cpus::get_physical())) // Use all host cores, unless single-cored in which case pretend to have 2
    .thread_stack_size(8 * 1024 * 1024)
    .enable_time()
    .enable_io()
    .build()?;

  rt.block_on(async {
    if let Err(e) = main_async().await {
      eprintln!("[ main_async ] {}", e);
      std::process::exit(1);
    }
  });

  Ok(())
}

async fn main_async() -> Result<(), Box<dyn std::error::Error>> {
  use oliana_server_lib::Oliana;

  let args: Vec<String> = std::env::args().collect();
  let default_server_url = "localhost:9050".to_string();
  let server_url = args.get(1).unwrap_or(&default_server_url);
  println!("server_url = {:?}", server_url);

  let some_name = "John Smith".to_string();

  let mut transport = tarpc::serde_transport::tcp::connect(server_url, tarpc::tokio_serde::formats::Bincode::default);
  transport.config_mut().max_frame_length(usize::MAX);

  // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
  // config and any Transport as input.
  let client = oliana_server_lib::OlianaClient::new(tarpc::client::Config::default(), transport.await?).spawn();

  let hello = async move {
      // Send the request twice, just to be safe! ;)
      tokio::select! {
          hello1 = client.hello(tarpc::context::current(), format!("{}1", some_name)) => { hello1 }
          hello2 = client.hello(tarpc::context::current(), format!("{}2", some_name)) => { hello2 }
      }
  }
  .await;

  match hello {
      Ok(hello) => eprintln!("Recieved: {hello:?}"),
      Err(e) => eprintln!("{:?}", e),
  }

  Ok(())
}
