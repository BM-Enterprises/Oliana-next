
#![allow(unused_imports, unused_variables)]

use futures::prelude::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let rt  = tokio::runtime::Builder::new_multi_thread()
    .worker_threads(std::cmp::max(2, num_cpus::get_physical())) // Use all host cores, unless single-cored in which case pretend to have 2
    .thread_stack_size(8 * 1024 * 1024)
    .enable_time()
    .enable_io()
    .build()?;

  rt.block_on(async {
    if let Err(e) = main_async().await {
      eprintln!("[ main_async ] {}", e);
      std::process::exit(1);
    }
  });

  Ok(())
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}

async fn main_async() -> Result<(), Box<dyn std::error::Error>> {
    use tarpc::server::Channel;
    use oliana_server_lib::Oliana;
    use futures::StreamExt;
    use tarpc::server::incoming::Incoming;

    let port: u16 = 9050;

    let ipv4_server_addr = (std::net::IpAddr::V4(std::net::Ipv4Addr::LOCALHOST), port);
    let ipv6_server_addr = (std::net::IpAddr::V6(std::net::Ipv6Addr::LOCALHOST), port);

    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    let mut ipv4_listener = tarpc::serde_transport::tcp::listen(&ipv4_server_addr, tarpc::tokio_serde::formats::Bincode::default).await?;
    let mut ipv6_listener = tarpc::serde_transport::tcp::listen(&ipv6_server_addr, tarpc::tokio_serde::formats::Bincode::default).await?;

    println!("Listening on {:?}", &ipv4_server_addr);
    println!("Listening on {:?}", &ipv6_server_addr);

    ipv4_listener.config_mut().max_frame_length(usize::MAX);
    ipv6_listener.config_mut().max_frame_length(usize::MAX);

    tokio::join!(
        ipv4_listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(tarpc::server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                let server = oliana_server_lib::OlianaServer::new( channel.transport().peer_addr().expect("IPv4 Client had no peer_addr!") );
                channel.execute(server.serve()).for_each(spawn)
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {}),
        ipv6_listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(tarpc::server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                let server = oliana_server_lib::OlianaServer::new( channel.transport().peer_addr().expect("IPv6 Client had no peer_addr!") );
                channel.execute(server.serve()).for_each(spawn)
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {}),
    );


    Ok(())
}

